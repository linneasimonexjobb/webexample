{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Welcome to this example wiki. In here there are guides on how to set up a project using MkDocs, git-prehooks, CI/CD, Docker, issue tracking and other means to make the greenhouse process a bit more streamlined.</p> <p>Everything done here is just an example and one may use the template, or alter things if you deem neccecary.</p> <p>This first version is made by the master students Simon and Linn\u00e9a at Link\u00f6ping University.</p>"},{"location":"#navigation","title":"Navigation","text":"<p>Write where the different navigations take you in the wiki.</p> <p>In this wiki, we have configured the different tools of DevOps in each NavBar</p> <p>We recommend having a documentation tidy and easy to maintain. An example would be:</p> <p><pre><code>project_root/\n\u2502\n\u251c\u2500\u2500 wiki/\n\u2502   \u251c\u2500\u2500 index.md\n\u2502   \u251c\u2500\u2500 Project\n\u2502   \u2502    \u251c\u2500\u2500 description.md\n\u2502   \u2502    \u2502   \n\u2502   \u2514\u2500\u2500 ... (other top-level pages)\n\u2502\n\u251c\u2500\u2500 mkdocs.yml\n\u2502\n\u2514\u2500\u2500 site/ (auto-generated)\n</code></pre> MkDocs only support two layers of nesting, so making use of md headers within each folder is crucial.</p>"},{"location":"#purpose-of-project","title":"Purpose of project","text":"<p>Write down a few sentences what you are trying to achieve with the project. This helps with setting a goal and help others understand what the purpose is.</p>"},{"location":"#requirments","title":"Requirments","text":"<p>If you have any technical or non-technical requirements, it could declared here with the help of tables, for example:</p> Requirement Description Login user One may only authorize once Delete message A user should be able to delete messages Logout a User should be able to logout from the site"},{"location":"CI/ci/","title":"why continious integration","text":"<p>To validate that the code is following certain standards, builds and tests correctly. A CI template has been created that the developers may use.</p> <p>The CI runs on GitHub actions and has a few steps the devs need to assert.</p>"},{"location":"CI/ci/#ci-configuration","title":"CI configuration","text":"<p>The CI runs with the steps:</p> Steps Description Lint Linting is used to verify that the code is properly structured, GitHub super-lint is used but can be changed to whatever the devs find appropriate Build The project should be built, here you may use cmake, npm build etc test Atleast basic unit test should be used in the project"},{"location":"CI/ci/#ci-pipeline","title":"CI pipeline","text":"<p>The CI pipeline(s) are always defined in <code>.github/workflows</code>, a general build may look like this</p> <pre><code>name: vue-3-ci\n\non:\n  push:\n    branches:\n      - \"dev/**\" # Push can only be done to develepment branches\n  pull_request:\n    types:\n      - closed\n\npermissions:\n  actions: read # The workflow is read only\n\n# Ensures that only one workflow per branch/environment will be run\nconcurrency:\n  group: ${{ github.head_ref || github.ref_name }} \n  cancel-in-progress: true\n\njobs:\n  build:\n    runs-on: ubuntu-22.04\n    timeout-minutes: 30 #job times out after 30 mins\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3\n\n    - name: Setup Node.js\n      uses: actions/setup-node@v3\n      with:\n        node-version: 18 # Change this to the desired Node.js version\n\n    # Cache dependencies for faster workflow\n    - name: Cache dependencies\n      uses: actions/cache@v3\n      with:\n          path: ~/.npm # Can potentially create cache of /node_modules folder but could create conflicts\n          key: ${{ runner.OS }}-node-${{ hashFiles('**/package-lock.json') }}\n          restore-keys: |\n            ${{ runner.OS }}-node-\n\n    - name: Install dependencies\n      run: npm ci\n\n    - name: Run Tests\n      run: npm run test:unit &amp;&amp; npm run test:coverage # Change this to your test command\n\n    - name: Lint code\n      run: npm run lint # Change this to your linting command\n\n    - name: Build\n      run: npm run build # Change this to your build command\n\n    - name: Archive artifacts\n      uses: actions/upload-artifact@v3\n      with:\n        name: dist\n        path: dist\n\n  if_merged:\n    needs: build\n    if: github.event.pull_request.merged == true\n    runs-on: ubuntu-22.04\n    timeout-minutes: 30 #job times out after 30 mins\n    steps:\n    - name: Deploy\n      run: |\n        echo The PR was merged\n</code></pre>"},{"location":"MkDocs/mkdocs-ci/","title":"MkDocs CI","text":"<p>To keep the documentation updated. A CI is used to validate the changes made to the wiki page. For now, GitHub Actions is used to run a CI/CD and deploy to GitHub pages. This might change in the future but the file is situated in <code>.github/workflows/mkdocs.yml</code>. The CI runs MkDocs when a change is merged into the main branch, this updates the gh-deploy branch with the update and is deployed to gh-pages.</p> <pre><code>name: mkdocs-ci\n\non:\n  push:\n    branches:\n      - main\n\npermissions:\n  contents: write\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v2\n\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: 3.x\n\n      - name: Install dependencies\n        run: |\n          pip install mkdocs-material pillow cairosvg\n\n      - name: Build and Deploy MkDocs\n        run: |\n          cd wiki\n          mkdocs build\n          mkdocs gh-deploy --force\n</code></pre>"},{"location":"MkDocs/mkdocs-features/","title":"Features","text":""},{"location":"MkDocs/mkdocs-writing/","title":"MkDocs","text":"<p>Requirements to run MkDocs: <code>Python 3.x</code></p> <p>More source material  MkDocs wiki</p> <p>Material for MkDoc</p>"},{"location":"MkDocs/mkdocs-writing/#what-is-mkdocs","title":"What is MkDocs","text":"<p>MkDocs is a fast and straightforward static site generator that allows users to build project documentation with ease. It is commonly used for creating user-friendly documentation for software projects, APIs, and other similar resources. MkDocs operates on Markdown files, enabling developers to focus on writing content without worrying about of HTML or CSS. This tool is highly customizable, offering various themes and extensions to tailor the documentation's appearance and functionality. With its user-friendly interface and seamless integration with version control systems, MkDocs is a popular choice for teams looking to create professional and accessible documentation for their projects.</p>"},{"location":"MkDocs/mkdocs-writing/#material-for-mkdocs","title":"Material for MkDocs","text":"<p>Material for MkDocs is a popular theme that enhances the visual appeal and user experience of documentation generated by MkDocs. Inspired by Google's Material Design, this theme provides a modern and polished look to project documentation, making it more engaging and accessible for users. Material for MkDocs integrates sleek design elements, such as responsive layouts, customizable navigation, and a clear typography hierarchy, to create an intuitive and aesthetically pleasing documentation site. This theme also supports various customization options, allowing users to fine-tune the appearance of their documentation to suit their specific branding and style preferences. With its emphasis on usability and visual appeal, Material for MkDocs is a favored choice for developers and teams seeking to elevate the presentation of their project documentation.</p>"},{"location":"MkDocs/mkdocs-writing/#configuring-mkdocs","title":"Configuring MkDocs","text":"<p>In the <code>mkdocs.yml</code> file situated in the root of the wiki one could add or remove features of MkDocs. We recommend using the plugins provided to streamline all Greenhouse projects with same template.</p> <p>To add headers and files, the <code>nav:</code> needs to be updated. Here you can see how this wiki is structured.</p> <pre><code>nav:\n  - Home: 'index.md'\n  - Project: \n    - 'Structure': 'Project/project.md'\n    - 'Test': 'Project/testing/test.md'\n    - Source:\n      - 'src': 'Project/src/src.md'\n      - 'components': \"Project/src/components/components.md\"\n  - MkDocs:\n    - 'Writing MkDocs': 'MkDocs/mkdocs-writing.md'\n    - 'CI/CD With MkDocs': 'MkDocs/mkdocs-ci.md'\n  - CI/CD:\n    - 'Contiuous integration': 'CI/ci.md'\n  - Git prehooks:\n    - 'prehooks': 'git/prehooks.md'\n  - GitHub issues and kanban board:\n    - Issues: 'github/issues.md'\n    - Kanban board: 'github/kanban.md'\n</code></pre> <p>We recommend using folders to keep the md files organized. If the project contains many folders, a good rule of thumb is to have a md file for every folder, explaining what the folder contains</p> <p>For more information about plugins, please read the documentation provided: squidfunk</p>"},{"location":"Project/project/","title":"Example Project","text":"<p>This is an example project on how MkDocs could be set up to support knowledge sharing</p>"},{"location":"Project/project/#folder-structure","title":"Folder structure","text":""},{"location":"Project/project/#src","title":"src","text":"<p>Contains the source code of x project</p>"},{"location":"Project/project/#testing","title":"testing","text":"<p>The folder contains unit tests and y test to the project</p>"},{"location":"Project/src/src/","title":"Src","text":""},{"location":"Project/src/src/#components","title":"Components","text":"<p>Components are used to run the application with ......</p>"},{"location":"Project/src/components/components/","title":"Components","text":"<p>General knowledge of how the components work, if larger file, it might be good to create an md file of the specific component.</p> <p>Code snippets is good to have if there is something that is hard to understand by only looking at the code</p> <p>Example: <pre><code>def create_markdown_file(file_name, content):\n    with open(file_name, 'w') as f:\n        f.write(content)\n    print(f\"Markdown file '{file_name}' created successfully.\")\n</code></pre></p>"},{"location":"Project/testing/test/","title":"Testing","text":"<p>In the project, unit and e2e testing is done by....</p>"},{"location":"Project/testing/test/#unit","title":"Unit","text":"<p>To run the unit test, type <code>npm test:unit</code> to run the unit tests</p>"},{"location":"Project/testing/test/#e2e","title":"E2E","text":"<p>To run the e2e test, type <code>npm test:e2e</code> to run the tests. E2E test is using Microsoft playwright to emluate....</p>"},{"location":"git/prehooks/","title":"Pre-hooks","text":"<p>Git pre-hooks are scripts that you can use to enforce certain criteria or perform checks before a Git operation is executed. They are useful for ensuring code quality, running tests, or preventing commits that do not meet specific standards.</p> <p>The pre-hook scripts can be written in any scripting language such as Bash, Python, or Ruby, depending on your requirements and preferences. The main pre-hooks that Git supports are:</p> <p>pre-commit: This hook is invoked before a commit is created. It can be used to inspect the snapshot that is about to be committed.</p> <p>pre-rebase: This hook is invoked before a branch is rebased. It can be used to ensure that the branch being rebased is in a suitable state.</p> <p>pre-receive: This hook is invoked on the remote repository once it has received a push but before it updates any refs. It can be used to check the pushed commits for consistency and quality.</p> <p>pre-push: This hook is invoked before a push to a remote repository is executed. It can be used to ensure that the pushed changes meet certain criteria.</p>"},{"location":"git/prehooks/#pre-commit","title":"Pre-commit","text":"<p>Git pre-commit hooks are scripts that run before the commit is created. They can be used to inspect the snapshot that is about to be committed and to ensure that it passes certain criteria. If the script exits with a non-zero status, the commit is aborted. Pre-commit hooks are useful for tasks such as checking for trailing whitespace, ensuring commit messages follow a certain pattern, or running tests before allowing a commit.</p> <p>To set up a Git pre-commit hook, follow these steps:</p> <p>Navigate to the .git directory of your project.</p> <p>Go to the hooks subdirectory. If it doesn't exist, you can create it.</p> <p>Create a new file named pre-commit (without any file extension) in the hooks directory.</p>"},{"location":"git/prehooks/#commit-message","title":"Commit message","text":"<p>With pre-commit, a set of specified tags can be enforced using git. For example you may need to tag the commit with dev, test, bug etc to know what the commit did. A decription may also be added that requires specific characteristics to be passed. This can ofcourse be turned of if the developer may find it too enforcing. However, we recommed having some kind of pre-commit message requirement so valuable commit messages are only let through.</p>"},{"location":"git/prehooks/#prettier","title":"Prettier","text":"<p>You may also use code styling enforcers before commiting your code. For example, prettier can change the code corretly directly.</p>"}]}